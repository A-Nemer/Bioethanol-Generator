<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schematic Bioethanol Distillation Unit (3D)</title>
    <!-- Load Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls for camera movement -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Using a monospace font similar to a digital sensor readout -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #0f172a; display: flex; }
        canvas { display: block; flex-grow: 1; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #f8fafc;
            font-size: 24px;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }
        #controls-hint {
            position: absolute;
            bottom: 10px;
            left: 20px;
            color: #cbd5e1;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 5px;
            z-index: 10;
        }
        #control-panel {
            width: 350px;
            background: #1e293b;
            color: #f8fafc;
            padding: 20px;
            overflow-y: auto;
            border-left: 2px solid #334155;
            z-index: 10;
            height: 100vh;
        }
        .stage-button {
            transition: all 0.2s;
        }
        .stage-button.active {
            background-color: #10b981;
            box-shadow: 0 0 10px #10b981;
        }
        .stage-button:disabled {
            background-color: #374151;
            cursor: not-allowed;
            opacity: 0.7;
        }
        /* Custom styling to match schematic/industrial look */
        .sensor-readout {
            background-color: #003300;
            color: #33FF33;
            border: 1px solid #10b981;
            box-shadow: 0 0 5px #10b981;
        }
    </style>
</head>
<body>
    <div id="info">Bioethanol Production & Distillation Schematic (3D Model)</div>

    <!-- Control Panel for Stepping Through Stages -->
    <div id="control-panel">
        <h2 class="text-xl font-bold mb-4 text-cyan-400">Process Control</h2>
        <div id="current-stage-display" class="bg-gray-700 p-3 rounded-lg mb-4 text-center text-lg font-mono">
            STAGE 1: MASHING & ENZYMES
        </div>
        <p class="text-sm text-gray-400 mb-4">Advance the simulation through the steps of the bioethanol production process shown in the sketch.</p>
        
        <button id="next-stage-button" class="stage-button w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-3 rounded-lg shadow-lg">
            Next Stage (1/5)
        </button>

        <h3 class="text-lg font-bold mt-6 mb-2 text-gray-300">Current Status (Sensors)</h3>
        <p id="stage-description" class="text-sm text-gray-400">
            Mashing: Waste (seeds) is blended with water to prepare the sugar slurry for fermentation.
        </p>

        <h3 class="text-lg font-bold mt-6 mb-2 text-gray-300">Sensor Readout</h3>
        <div class="sensor-readout p-3 rounded font-mono text-sm space-y-2">
            <div class="flex justify-between">Temperature: <span id="status-temp">20.0 °C</span></div>
            <div class="flex justify-between">pH: <span id="status-ph">6.5 (Neutral)</span></div>
            <div class="flex justify-between">Ethanol Vapors: <span id="status-ethanol">0%</span></div>
        </div>
    </div>

    <div id="controls-hint">Use mouse/touch to rotate (left click) and zoom (scroll/pinch). Click the yellow drawer to remove/insert it.</div>

    <script>
        // Global variables for Three.js and Simulation State
        let scene, camera, renderer, controls, heatSourceLight;
        let blenderTank, filtrationTank; 
        let distillationVaporPath = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // --- UPDATED CONSTANTS FOR ELEVATION AND REPOSITIONING ---
        // Increased elevation for gravity feed to Filtration Tank
        const BLENDER_TANK_ELEVATION = 3.0; 
        const COLLECTION_BOX_HEIGHT = 2.5; 
        const COLLECTION_BOX_POSITION = new THREE.Vector3(6.5, COLLECTION_BOX_HEIGHT / 2, 0.0); 
        const COLLECTION_LIQUID_HEIGHT = COLLECTION_BOX_HEIGHT - 0.2; 
        const COLLECTION_LIQUID_BASE_Y = 0.0; 
        const FILTRATION_TANK_HEIGHT = 1.5;

        // --- SIMULATION STATE ---
        const SIM_STATE = {
            stage: 1,
            maxStages: 5,
            temp: 20.0,
            ph: 6.5,
            ethanol: 0,
            statusText: "MASHING",
            // 3D Model References
            blenderContentMesh: null,
            filtrationLiquidMesh: null,
            collectionContentMesh: null, 
            blenderPropeller: null,
            heatSourceFlame: null,
            solidsDrawer: null, 
            isDrawerOpen: false, 
        };

        // --- STAGE DEFINITIONS (Matched to sketch flow) ---
        const STAGES = {
            1: { name: "MASHING & ENZYMES", status: "MASHING", temp: 20.0, ph: 6.5, ethanol: 0, desc: "Input waste (seeds/peels) and water. The impeller blends the mixture to create a sugar slurry.", blending: true, filtration: 0, collection: 0, heat: false },
            2: { name: "PRIMARY FERMENTATION", status: "FERMENTING", temp: 35.0, ph: 4.0, ethanol: 0, desc: "Yeast is added. Sugars convert to ethanol and CO₂ (seen as bubbles). High heat/acidity peak.", blending: false, filtration: 0, collection: 0, heat: false },
            3: { name: "FILTRATION & SETTLING", status: "FILTERING", temp: 30.0, ph: 4.5, ethanol: 0, desc: "The automated door opens. Liquid fermentate drains to the lower tank for settling/filtration, retaining solids.", blending: false, filtration: 0.8, collection: 0, heat: false },
            4: { name: "DISTILLATION & HEATING", status: "DISTILLING", temp: 80.0, ph: 5.0, ethanol: 0.5, desc: "The fermentate is heated in the flask. Ethanol vaporizes, condenses, and is collected in the purification unit.", blending: false, filtration: 0.8, collection: 0.2, heat: true },
            5: { name: "ETHANOL COLLECTION", status: "COLLECTED", temp: 25.0, ph: 6.0, ethanol: 1.0, desc: "Distilled liquid fills the collector, signifying completion of the purification stage.", blending: false, filtration: 0.8, collection: 0.8, heat: false },
        };

        // --- Utility Functions ---

        function createTextSprite(message, color = '#ffffff', fontSize = 20, borderColor = '#000000', backgroundColor = 'rgba(0,0,0,0.7)') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontString = `Bold ${fontSize}px Arial`;
            context.font = fontString;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            
            const borderSize = 2;
            canvas.width = textWidth + borderSize * 4; 
            canvas.height = fontSize * 1.5;
            
            context.font = fontString;
            context.fillStyle = backgroundColor;
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.strokeStyle = borderColor;
            context.lineWidth = borderSize;
            context.strokeRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = color;
            context.textAlign = 'left';
            context.textBaseline = 'top';
            context.fillText(message, borderSize * 2, borderSize + (fontSize * 0.2));

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width / 100, canvas.height / 100, 1.0);
            return sprite;
        }

        function createLabel(text, position, offset = new THREE.Vector3(0, 0.5, 0)) {
            const sprite = createTextSprite(text, '#f8fafc', 25, '#000000', 'rgba(17, 24, 39, 0.8)');
            sprite.position.copy(position).add(offset);
            scene.add(sprite);
        }
        
        /**
         * Creates a pipe mesh from a series of straight line segments.
         * @param {THREE.Vector3[]} points - Array of points defining the path.
         * @param {number} color - Pipe color.
         * @returns {THREE.Mesh} The pipe mesh.
         */
        function createPipePath(points, color) {
            const path = new THREE.CurvePath();
            for (let i = 0; i < points.length - 1; i++) {
                path.add(new THREE.LineCurve3(points[i], points[i + 1]));
            }
            // Use a higher tubular segment count for smoother connections
            const geometry = new THREE.TubeGeometry(path, 128, 0.1, 8, false); 
            const material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.8, roughness: 0.1 });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            return mesh;
        }


        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e293b);

            // Camera Setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 7, 12); // Moved camera up slightly
            
            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth - 350, window.innerHeight); 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.insertBefore(renderer.domElement, document.getElementById('control-panel')); 

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 15, 7.5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Heat Source Light (for distillation)
            heatSourceLight = new THREE.PointLight(0xffa500, 0, 5, 2); 
            scene.add(heatSourceLight);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 25;

            buildModel();
            setupEventListeners();
            updateControlPanel(); 
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- Model Geometry Functions ---
        
        function createPlatform() {
            // Base to hold the apparatus (Total width 15 units)
            const platformGeometry = new THREE.BoxGeometry(15, 0.5, 8);
            const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x94a3b8, roughness: 0.5, metalness: 0.1 });
            const platformMesh = new THREE.Mesh(platformGeometry, platformMaterial);
            platformMesh.position.y = -0.25;
            platformMesh.receiveShadow = true;
            scene.add(platformMesh);
        }

        function createBlenderTank() {
            const group = new THREE.Group();
            
            const TANK_ELEVATION = BLENDER_TANK_ELEVATION; // NEW: 3.0
            const TANK_HEIGHT = 2.5; 
            const TANK_CENTER_Y = TANK_ELEVATION + (TANK_HEIGHT / 2); // 4.25

            // Support Stand (Box under the cylinder)
            const standGeo = new THREE.BoxGeometry(3.0, TANK_ELEVATION, 3.0); // Height is TANK_ELEVATION (3.0)
            const standMaterial = new THREE.MeshStandardMaterial({ color: 0x475569, roughness: 0.7 });
            const standMesh = new THREE.Mesh(standGeo, standMaterial);
            standMesh.position.y = TANK_ELEVATION / 2; // Center at 1.5
            standMesh.castShadow = true;
            group.add(standMesh);
            
            // --- Fermentation Tank (Cylinder 1) ---
            const bodyGeometry = new THREE.CylinderGeometry(2.0, 2.0, TANK_HEIGHT, 32); 
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            bodyMesh.position.y = TANK_CENTER_Y; // Center at 4.25
            group.add(bodyMesh);

            // Tank Contents (Slurry)
            const contentGeometry = new THREE.CylinderGeometry(1.9, 1.9, 2.2, 32); 
            const contentMaterial = new THREE.MeshStandardMaterial({ color: 0x334155, roughness: 0.8, transparent: true, opacity: 0.8 }); 
            SIM_STATE.blenderContentMesh = new THREE.Mesh(contentGeometry, contentMaterial);
            SIM_STATE.blenderContentMesh.position.y = TANK_ELEVATION + 1.35; // Positioned relative to the elevated base
            group.add(SIM_STATE.blenderContentMesh);

            // Blending Propeller 
            const propGeo = new THREE.BoxGeometry(0.2, 1.5, 0.2);
            const propMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9 });
            SIM_STATE.blenderPropeller = new THREE.Mesh(propGeo, propMaterial);
            SIM_STATE.blenderPropeller.rotation.x = Math.PI / 2;
            SIM_STATE.blenderPropeller.position.y = TANK_ELEVATION + 0.5; 
            
            const prop2 = SIM_STATE.blenderPropeller.clone();
            prop2.rotation.y = Math.PI / 2;
            
            const propellerGroup = new THREE.Group();
            propellerGroup.add(SIM_STATE.blenderPropeller);
            propellerGroup.add(prop2);
            group.add(propellerGroup);

            // Outlet Door at the bottom of the elevated tank
            const doorGeo = new THREE.BoxGeometry(0.3, 0.5, 0.1);
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const doorMesh = new THREE.Mesh(doorGeo, doorMaterial);
            // Positioned at the right edge (2.0) of the cylinder, centered at Y=3.25 (3.0 + 0.25)
            doorMesh.position.set(2.0, TANK_ELEVATION + 0.25, 0.0); 
            group.add(doorMesh);

            // Label
            createLabel("Fermentation Tank", group.position, new THREE.Vector3(0, TANK_ELEVATION + 2.8, 0)); 

            group.position.set(-6.0, 0, 0); // Far left position (Group base is at Y=0)
            scene.add(group);
            blenderTank = group;
        }

        function createFiltrationBed() {
            const group = new THREE.Group();
            
            // Dimensions for Flat Tank
            const TANK_HEIGHT = FILTRATION_TANK_HEIGHT; // 1.5
            const TANK_CENTER_Y = TANK_HEIGHT / 2; // 0.75
            const TANK_TOP_Y = TANK_HEIGHT; // 1.5
            
            // Define liquid metrics relative to the drawer
            const DRAWER_HEIGHT = 0.2;
            const DRAWER_Y_POS = 0.5; // Center Y of the drawer (0.4 to 0.6)
            const LIQUID_BASE_Y = DRAWER_Y_POS + (DRAWER_HEIGHT / 2); // 0.6 (where liquid rests)
            const NEW_LIQUID_MAX_HEIGHT = TANK_HEIGHT - LIQUID_BASE_Y - 0.1; // 1.5 - 0.6 - 0.1 = 0.8 max height

            // Lower Filtration Tank Housing (Square 2)
            const housingGeometry = new THREE.BoxGeometry(3, TANK_HEIGHT, 3); 
            const housingMaterial = new THREE.MeshStandardMaterial({ color: 0x6b7280, roughness: 0.5 });
            const housingMesh = new THREE.Mesh(housingGeometry, housingMaterial);
            housingMesh.position.y = TANK_CENTER_Y; 
            group.add(housingMesh);

            // Filtration top frame/lid
            const topFrameGeometry = new THREE.BoxGeometry(2.8, 0.3, 2.8);
            const topFrameMaterial = new THREE.MeshStandardMaterial({ color: 0x9ca3af, roughness: 0.9 });
            const topFrameMesh = new THREE.Mesh(topFrameGeometry, topFrameMaterial);
            topFrameMesh.position.set(0, TANK_TOP_Y + (0.3/2), 0); 
            group.add(topFrameMesh);

            // --- Solids Collector Drawer (The removable part) ---
            const drawerGeometry = new THREE.BoxGeometry(2.8, DRAWER_HEIGHT, 2.8);
            const drawerMaterial = new THREE.MeshStandardMaterial({ color: 0xfacc15, roughness: 0.8, metalness: 0.2 }); // Distinct Yellow/Gold
            SIM_STATE.solidsDrawer = new THREE.Mesh(drawerGeometry, drawerMaterial);
            
            // Store the initial position for easy reset
            SIM_STATE.solidsDrawer.userData.initialPosition = new THREE.Vector3(0, DRAWER_Y_POS, 0); 
            SIM_STATE.solidsDrawer.position.copy(SIM_STATE.solidsDrawer.userData.initialPosition);
            SIM_STATE.solidsDrawer.name = 'SolidsDrawer'; // For raycasting interaction
            SIM_STATE.solidsDrawer.castShadow = true;
            group.add(SIM_STATE.solidsDrawer);


            // Liquid Level (Fermentate) - sits above the drawer
            const liquidGeometry = new THREE.BoxGeometry(2.8, NEW_LIQUID_MAX_HEIGHT, 2.8);
            const liquidMaterial = new THREE.MeshStandardMaterial({ color: 0x22c55e, transparent: true, opacity: 0.7 }); 
            SIM_STATE.filtrationLiquidMesh = new THREE.Mesh(liquidGeometry, liquidMaterial);
            
            // Liquid mesh centered based on its new base and height
            SIM_STATE.filtrationLiquidMesh.position.set(0, LIQUID_BASE_Y + (NEW_LIQUID_MAX_HEIGHT / 2), 0); 
            SIM_STATE.filtrationLiquidMesh.scale.y = 0.001; // Start empty
            
            // Store scaling metrics for update3DVisuals
            SIM_STATE.filtrationLiquidMesh.userData.liquidBaseY = LIQUID_BASE_Y;
            SIM_STATE.filtrationLiquidMesh.userData.maxHeight = NEW_LIQUID_MAX_HEIGHT;

            group.add(SIM_STATE.filtrationLiquidMesh);
            
            // --- NEW PIPE: Inlet from Blender Tank (GRAVITY FEED) ---
            const blenderPos = new THREE.Vector3(-6.0, 0, 0); // Blender group position
            const filterPos = new THREE.Vector3(-1.5, 0, 0); // Filtration group position
            
            // Start: Bottom outlet of Blender Tank (x=-4.0, y=3.25, z=0.0) 
            const inletPipeStart = new THREE.Vector3(blenderPos.x + 2.0, BLENDER_TANK_ELEVATION + 0.25, blenderPos.z); 
            // End: Top center of Filtration Tank (y=1.5)
            const inletPipeEnd = new THREE.Vector3(filterPos.x, filterPos.y + TANK_TOP_Y, filterPos.z);
            
            // Define points for a clean L-bend, ensuring flow is downhill (3.25 -> 1.5)
            const gravityPipePoints = [
                inletPipeStart,                                         // 1. Start: (-4.0, 3.25, 0.0)
                new THREE.Vector3(filterPos.x, inletPipeStart.y, 0.0), // 2. Horizontal: (-1.5, 3.25, 0.0)
                inletPipeEnd                                            // 3. Drop: (-1.5, 1.5, 0.0)
            ];
            
            createPipePath(gravityPipePoints, 0xaaaaaa);
            
            // Automated Door (Outlet for the pipe leading to distillation)
            const doorGeo = new THREE.BoxGeometry(0.3, 0.5, 0.1);
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const doorMesh = new THREE.Mesh(doorGeo, doorMaterial);
            doorMesh.position.set(1.5, 0.5, 0.0); // Outlet is low down on the 1.5 unit box
            group.add(doorMesh);
            
            // Label
            createLabel("Filtration Tank", group.position, new THREE.Vector3(0, TANK_TOP_Y + 0.5, 0)); 

            group.position.set(-1.5, 0, 0); // Middle-left position
            scene.add(group);
            filtrationTank = group;
        }


        function createDistillationSetup() {
            const group = new THREE.Group();
            
            // --- 1. Distillation Flask (The "hanging glass thingy" / Ball) ---
            const flaskPosition = new THREE.Vector3(4.0, 2.5, 0.0);
            const flaskGeo = new THREE.SphereGeometry(1.0, 32, 32); 
            const flaskMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, transmission: 0.9, transparent: true, opacity: 0.8, roughness: 0.1, metalness: 0
            });
            const flaskMesh = new THREE.Mesh(flaskGeo, flaskMaterial);
            flaskMesh.position.copy(flaskPosition);
            group.add(flaskMesh);
            createLabel("Distillation Flask (Boiling)", flaskPosition, new THREE.Vector3(0, 1.2, 0));

            // --- 2. Heat Source (Candle/Flame) - Directly under the flask ---
            const heatPosition = new THREE.Vector3(4.0, 0.5, 0.0);
            const candleGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.0, 16);
            const candleMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.5 });
            const candleMesh = new THREE.Mesh(candleGeo, candleMaterial);
            candleMesh.position.copy(heatPosition);
            group.add(candleMesh);
            
            // Update heatSourceLight position to be at the flame
            heatSourceLight.position.set(heatPosition.x, heatPosition.y + 0.5, heatPosition.z); 

            // Flame
            const flameGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const flameMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500, emissive: 0xffa500, emissiveIntensity: 0 });
            SIM_STATE.heatSourceFlame = new THREE.Mesh(flameGeo, flameMaterial);
            SIM_STATE.heatSourceFlame.position.set(heatPosition.x, heatPosition.y + 0.5, heatPosition.z);
            group.add(SIM_STATE.heatSourceFlame);
            createLabel("Heat Source", heatPosition, new THREE.Vector3(0, 1.0, 0));

            // --- 3. NEW PIPE: Inlet from Filtration Tank (ZIGZAG PUMPED FEED) ---
            const filtrationGroupPos = new THREE.Vector3(-1.5, 0, 0); 
            
            // Start: Outlet on Filtration Tank (Absolute: 0.0, Y=0.5)
            const inletPipeStart = new THREE.Vector3(filtrationGroupPos.x + 1.5, filtrationGroupPos.y + 0.5, filtrationGroupPos.z); 
            
            // End: Inlet on Distillation Flask (Absolute: 3.5, Y=1.5)
            const flaskInletPos = new THREE.Vector3(flaskPosition.x - 0.5, flaskPosition.y - 1.0, flaskPosition.z); 
            
            // Define points for the efficient zigzag path (Straight-Up-Straight)
            const pumpedPipePoints = [
                inletPipeStart,                                         // 1. Start: (0.0, 0.5, 0.0)
                new THREE.Vector3(flaskInletPos.x - 0.5, inletPipeStart.y, 0.0), // 2. Horizontal: (3.0, 0.5, 0.0)
                new THREE.Vector3(flaskInletPos.x - 0.5, flaskInletPos.y, 0.0),  // 3. Vertical Up: (3.0, 1.5, 0.0)
                flaskInletPos                                           // 4. Straight In: (3.5, 1.5, 0.0)
            ];

            createPipePath(pumpedPipePoints, 0xaaaaaa);
            
            
            // --- 4. Condenser Coil & Vapor Path (Up then Right) ---
            const condenserCenter = new THREE.Vector3(6.5, 3.5, 0.0); 
            const vaporStart = new THREE.Vector3(flaskPosition.x, flaskPosition.y + 1.0, flaskPosition.z); // Top of Distillation Flask

            // The vapor path remains curved as it represents a cooling coil
            const coilPath = new THREE.CatmullRomCurve3([
                vaporStart,
                new THREE.Vector3(vaporStart.x + 1.0, vaporStart.y + 1.0, vaporStart.z),
                new THREE.Vector3(condenserCenter.x - 0.5, 4.5, 0.0), 
                new THREE.Vector3(condenserCenter.x, 3.5, 0.0), 
                new THREE.Vector3(condenserCenter.x, 2.5, 0.0) // Coil exit point (dripStart)
            ]);
            const condenserGeometry = new THREE.TubeGeometry(coilPath, 64, 0.1, 8, false);
            const condenserMaterial = new THREE.MeshStandardMaterial({ color: 0x99ccff, metalness: 0.8, roughness: 0.1, transparent: true, opacity: 0.9 });
            const condenserMesh = new THREE.Mesh(condenserGeometry, condenserMaterial);
            group.add(condenserMesh);
            createLabel("Condenser Coil (Cooling)", condenserCenter, new THREE.Vector3(0, 1.5, 0));

            // Vapor path visualization (inside the condenser)
            const vaporMaterial = new THREE.MeshBasicMaterial({ color: 0xffe0b2, transparent: true, opacity: 0.0 });
            distillationVaporPath = new THREE.Mesh(condenserGeometry, vaporMaterial); 
            group.add(distillationVaporPath);


            // --- 5. Transparent Collection Unit with Liquid ---
            
            // Transparent Box (Collection Unit)
            const boxGeo = new THREE.BoxGeometry(2.5, COLLECTION_BOX_HEIGHT, 1.5);
            const boxMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, transmission: 0.9, transparent: true, opacity: 0.4, roughness: 0.1, metalness: 0
            });
            const boxMesh = new THREE.Mesh(boxGeo, boxMaterial);
            boxMesh.position.copy(COLLECTION_BOX_POSITION); 
            group.add(boxMesh);
            createLabel("Purified Liquid Collector", COLLECTION_BOX_POSITION, new THREE.Vector3(0, 1.6, 0));
            
            // Collected Liquid (Water blue color)
            const liquidGeometry = new THREE.BoxGeometry(2.3, COLLECTION_LIQUID_HEIGHT, 1.3); 
            const liquidMaterial = new THREE.MeshStandardMaterial({ color: 0x3b82f6, transparent: true, opacity: 0.8 });
            SIM_STATE.collectionContentMesh = new THREE.Mesh(liquidGeometry, liquidMaterial);
            
            SIM_STATE.collectionContentMesh.scale.y = 0.001;
            SIM_STATE.collectionContentMesh.position.set(COLLECTION_BOX_POSITION.x, COLLECTION_LIQUID_HEIGHT / 2, COLLECTION_BOX_POSITION.z);

            group.add(SIM_STATE.collectionContentMesh);

            scene.add(group);
        }


        function buildModel() {
            createPlatform();
            createBlenderTank();
            createFiltrationBed();
            createDistillationSetup();
        }

        // --- INTERACTION HANDLERS ---
        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            // Check only against the drawer mesh
            const intersects = raycaster.intersectObject(SIM_STATE.solidsDrawer, true);

            if (intersects.length > 0 && intersects[0].object.name === 'SolidsDrawer') {
                toggleSolidsDrawer();
            }
        }
        
        function toggleSolidsDrawer() {
            const drawer = SIM_STATE.solidsDrawer;
            if (!drawer) return;

            SIM_STATE.isDrawerOpen = !SIM_STATE.isDrawerOpen;

            // Target position: Pull out 2 units along the Z axis (to the front)
            const targetZ = SIM_STATE.isDrawerOpen ? drawer.userData.initialPosition.z + 2.0 : drawer.userData.initialPosition.z;

            // Instantly update position on interaction
            drawer.position.z = targetZ; 
        }

        // --- SIMULATION & STAGE HANDLER ---
        let bubbleTimer = 0;
        let bubbles = [];

        function createBubble(position, size = 0.01) {
            const geometry = new THREE.SphereGeometry(Math.random() * 0.1 + size, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.6 });
            const bubble = new THREE.Mesh(geometry, material);
            bubble.position.copy(position);
            bubble.velocity = new THREE.Vector3(0, Math.random() * 0.01 + 0.005, 0);
            return bubble;
        }

        function update3DVisuals(stage) {
            const data = STAGES[stage];
            SIM_STATE.temp = data.temp;
            SIM_STATE.ph = data.ph;
            SIM_STATE.ethanol = data.ethanol;
            SIM_STATE.statusText = data.status;
            
            // --- Reset Visuals ---
            heatSourceLight.intensity = 0;
            SIM_STATE.heatSourceFlame.material.emissiveIntensity = 0;
            distillationVaporPath.material.opacity = 0;

            // Use values stored in mesh user data for accurate scaling
            const LIQUID_BASE_Y = SIM_STATE.filtrationLiquidMesh.userData.liquidBaseY || (FILTRATION_TANK_HEIGHT / 2);
            const LIQUID_HEIGHT_REF = SIM_STATE.filtrationLiquidMesh.userData.maxHeight || FILTRATION_TANK_HEIGHT; 

            // --- Global Liquid Movement (Separation/Filtration) ---
            const filterScale = data.filtration;
            
            // Scale the liquid mesh to the desired fill level
            SIM_STATE.filtrationLiquidMesh.scale.y = filterScale;
            
            // Adjust position based on the new scale, anchored at LIQUID_BASE_Y
            SIM_STATE.filtrationLiquidMesh.position.y = LIQUID_BASE_Y + (filterScale * LIQUID_HEIGHT_REF / 2); 

            // --- Global Collection Level (Liquid Fill) ---
            const collectScale = data.collection;
            
            SIM_STATE.collectionContentMesh.scale.y = collectScale; 
            // Position moves up by half the scaled height, anchored at the base (Y=0.0)
            SIM_STATE.collectionContentMesh.position.y = COLLECTION_LIQUID_BASE_Y + (collectScale * COLLECTION_LIQUID_HEIGHT / 2);


            // --- Handle Stage-Specific Visuals ---
            switch (stage) {
                case 1: 
                    // Blending
                    SIM_STATE.blenderPropeller.rotationSpeed = 0.1;
                    break;
                case 2:
                    // Active Fermentation: Bubbling should be active
                    SIM_STATE.blenderPropeller.rotationSpeed = 0.0;
                    break;
                case 3:
                    // Filtration/Settling: Fermentate sits in lower tank
                    break;
                case 4:
                    // Distillation ON
                    heatSourceLight.intensity = 5; 
                    SIM_STATE.heatSourceFlame.material.emissiveIntensity = 5;
                    distillationVaporPath.material.opacity = 0.5;
                    distillationVaporPath.material.color.setHex(0xffe0b2); // Pale yellow for vapor
                    break;
                case 5:
                    // Final Collection
                    // Liquid level is full
                    break;
            }
        }

        function updateControlPanel() {
            const stage = SIM_STATE.stage;
            const data = STAGES[stage];

            document.getElementById('current-stage-display').textContent = `STAGE ${stage}: ${data.name}`;
            document.getElementById('stage-description').textContent = data.desc;
            document.getElementById('status-temp').textContent = `${SIM_STATE.temp.toFixed(1)} °C`;
            document.getElementById('status-ph').textContent = `${SIM_STATE.ph.toFixed(1)} (${SIM_STATE.ph < 5 ? 'Acidic' : 'Neutral'})`;
            document.getElementById('status-ethanol').textContent = SIM_STATE.ethanol > 0 ? `${(SIM_STATE.ethanol * 100).toFixed(0)}% Vapors Detected` : `0%`;


            const nextButton = document.getElementById('next-stage-button');
            if (stage < SIM_STATE.maxStages) {
                nextButton.textContent = `Next Step (${stage + 1}/${SIM_STATE.maxStages})`;
                nextButton.disabled = false;
            } else {
                nextButton.textContent = 'Process Complete (Collector Full)';
                nextButton.disabled = true;
            }
        }

        function handleNextStage() {
            if (SIM_STATE.stage < SIM_STATE.maxStages) {
                SIM_STATE.stage++;
                update3DVisuals(SIM_STATE.stage);
                updateControlPanel();
            }
        }

        function setupEventListeners() {
            document.getElementById('next-stage-button').addEventListener('click', handleNextStage);
            // NEW: Add click listener for drawer interaction
            renderer.domElement.addEventListener('click', onMouseClick, false);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Blending animation (Stage 1)
            if (SIM_STATE.stage === 1 && SIM_STATE.blenderPropeller) {
                SIM_STATE.blenderPropeller.rotation.y += 0.1;
            }
            
            // Bubbling effect during fermentation (Stage 2)
            if (SIM_STATE.stage === 2) {
                bubbleTimer++;
                if (bubbleTimer % 10 === 0) { // Add a new bubble every 10 frames
                    const newBubble = createBubble(new THREE.Vector3(
                        blenderTank.position.x + (Math.random() - 0.5) * 3.0,
                        BLENDER_TANK_ELEVATION + (Math.random() * 2.5) - 0.5, // Bubbles start within the elevated tank (Y=3.0 to 5.5)
                        blenderTank.position.z + (Math.random() - 0.5) * 3.0
                    ), 0.05); 
                    scene.add(newBubble);
                    bubbles.push(newBubble);
                }

                // Update bubble positions
                bubbles.forEach((bubble, index) => {
                    bubble.position.add(bubble.velocity);
                    bubble.material.opacity -= 0.005; 
                    if (bubble.position.y > 5.5 || bubble.material.opacity < 0.1) { // Max height of elevated tank
                        scene.remove(bubble);
                        bubbles.splice(index, 1); 
                    }
                });
            } else if (bubbles.length > 0) {
                // Clear bubbles if not in stage 2
                bubbles.forEach(bubble => scene.remove(bubble));
                bubbles = [];
            }

            renderer.render(scene, camera);
        }

        // --- Resize Handler ---
        function onWindowResize() {
            const controlPanelWidth = document.getElementById('control-panel').offsetWidth;
            const newWidth = window.innerWidth - controlPanelWidth;
            const newHeight = window.innerHeight;
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        }

        // Start the application
        window.onload = function () {
            init();
            update3DVisuals(SIM_STATE.stage); 
            animate();
        };

    </script>
</body>
</html>
